2025-12-05 22:20:11,130 - __main__ - INFO - Loaded data with 405575 rows.
2025-12-05 22:20:11,238 - __main__ - INFO - Starting Feature Engineering (Generation)...
2025-12-05 22:20:11,321 - src.features.pedigree - INFO - Loaded horse data: 51238 records
/Users/hiromu/Documents/keiba-ai/src/features/history.py:138: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.min()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:136: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.std()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:138: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.min()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:136: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.std()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:138: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.min()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:136: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.std()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:138: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.min()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:144: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.median()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:136: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.std()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:138: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.min()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:144: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.median()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:136: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.std()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:138: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.min()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:144: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.median()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:134: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.mean()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:136: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.std()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:138: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.min()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:140: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.max()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:144: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[col_name] = feature_base.median()
/Users/hiromu/Documents/keiba-ai/src/features/history.py:153: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['rank_momentum_5'] = df['rank_5_mean'] - df['prev_rank']
/Users/hiromu/Documents/keiba-ai/src/features/history.py:218: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_{cat}'] = grouped[f'rank_{cat}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99) if f'rank_{cat}' in df else 99
/Users/hiromu/Documents/keiba-ai/src/features/history.py:221: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{cat}'] = df['rank'].where(df['distance_category'] == cat)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:218: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_{cat}'] = grouped[f'rank_{cat}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99) if f'rank_{cat}' in df else 99
/Users/hiromu/Documents/keiba-ai/src/features/history.py:221: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{cat}'] = df['rank'].where(df['distance_category'] == cat)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:218: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_{cat}'] = grouped[f'rank_{cat}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99) if f'rank_{cat}' in df else 99
/Users/hiromu/Documents/keiba-ai/src/features/history.py:221: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{cat}'] = df['rank'].where(df['distance_category'] == cat)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:218: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_{cat}'] = grouped[f'rank_{cat}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99) if f'rank_{cat}' in df else 99
/Users/hiromu/Documents/keiba-ai/src/features/history.py:221: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{cat}'] = df['rank'].where(df['distance_category'] == cat)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:229: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{surf_name}'] = df['rank'].where(df['surface'] == surf)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:230: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_{surf_name}'] = grouped[f'temp_rank_{surf_name}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:229: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{surf_name}'] = df['rank'].where(df['surface'] == surf)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:230: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_{surf_name}'] = grouped[f'temp_rank_{surf_name}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:243: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'avg_rank_place_{p}'] = grouped[f'temp_rank_place_{p}'].transform(lambda x: x.shift(1).expanding().mean().ffill()).fillna(99)
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:253: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['weight_change_ratio'] = df['weight_change'] / df['horse_weight'].replace(0, np.nan)
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:269: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['is_win'] = (df['rank'] == 1).astype(int)
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:270: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['is_place'] = (df['rank'] <= 2).astype(int)
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:271: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['is_show'] = (df['rank'] <= 3).astype(int)
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:276: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['jockey_win_rate_100'] = df.groupby('jockey_id')['is_win'].transform(
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:280: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['jockey_place_rate_100'] = df.groupby('jockey_id')['is_place'].transform(
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:284: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['jockey_show_rate_100'] = df.groupby('jockey_id')['is_show'].transform(
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:291: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['trainer_win_rate_100'] = df.groupby('trainer_id')['is_win'].transform(
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:295: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['trainer_place_rate_100'] = df.groupby('trainer_id')['is_place'].transform(
/Users/hiromu/Documents/keiba-ai/experiments/v2_feature_expansion/v2_src/feature_engineering.py:299: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df['trainer_show_rate_100'] = df.groupby('trainer_id')['is_show'].transform(
2025-12-05 22:21:50,408 - __main__ - INFO - Generated columns: 314
2025-12-05 22:21:56,561 - __main__ - INFO - Train size: 324460, Test size: 81115
2025-12-05 22:21:56,562 - __main__ - INFO - Fitting Target Encoders on Training data...
/Users/hiromu/Documents/keiba-ai/src/features/history.py:221: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{cat}'] = df['rank'].where(df['distance_category'] == cat)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:221: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{cat}'] = df['rank'].where(df['distance_category'] == cat)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:221: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{cat}'] = df['rank'].where(df['distance_category'] == cat)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:221: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{cat}'] = df['rank'].where(df['distance_category'] == cat)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:229: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{surf_name}'] = df['rank'].where(df['surface'] == surf)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:229: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_{surf_name}'] = df['rank'].where(df['surface'] == surf)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
/Users/hiromu/Documents/keiba-ai/src/features/history.py:242: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead. To get a de-fragmented frame, use `newframe = frame.copy()`
  df[f'temp_rank_place_{p}'] = df['rank'].where(df['place'] == p)
2025-12-05 22:23:15,151 - __main__ - INFO - Applying Target Encoding...
2025-12-05 22:23:16,954 - __main__ - INFO - Final Feature Count: 281
2025-12-05 22:23:16,955 - __main__ - INFO - Features (Head): ['bracket', 'horse_num', 'gender', 'age', 'horse_weight', 'weight_change', 'surface', 'distance', 'weather', 'condition']
2025-12-05 22:23:17,761 - __main__ - INFO - Train size: 324460, Test size: 81115
2025-12-05 22:23:17,762 - __main__ - INFO - Training LightGBM...
2025-12-05 22:23:24,149 - __main__ - INFO - Evaluation Results - Accuracy: 0.9241, LogLoss: 0.2617, AUC: 0.6113
2025-12-05 22:23:24,344 - __main__ - INFO - Saved model to experiments/v2_feature_expansion/models/lgbm_v2.pkl
Training until validation scores don't improve for 50 rounds
Early stopping, best iteration is:
[7]	valid_0's binary_logloss: 0.261733

Top 20 Important Features:
                          feature  importance
278       horse_jockey_target_enc          65
14               final_corner_pos          37
29                    same_jockey          19
18                      prev_rank          11
200           prev_prize_race_max           8
37                     rank_5_min           7
32                     rank_3_min           7
205      prev_prize_diff_race_max           7
233        prize_5_mean_race_mean           6
203    prev_prize_ratio_race_mean           6
201     prev_prize_diff_race_mean           5
239  prize_5_mean_ratio_race_mean           5
42                    rank_10_min           4
228    rank_5_mean_diff_race_mean           3
192      prev_rank_diff_race_mean           2
202             prev_prize_zscore           2
238           prize_5_mean_zscore           2
197          prev_prize_race_mean           2
28                  prev_agari_3f           2
194     prev_rank_ratio_race_mean           2
